# -*- coding: utf-8 -*-
# OPENCLASSROOMS-COURSES-EXPLORER 
# Copyright (c) 2021, Tristan Vanrullen - all rights reserved.
# Note there is a licence for the code and another for the contents generated by the application
# see licence.txt for more details 


"""
Created on Sat May 29 00:23:34 2021

@author: Tristan
"""
 
from OCCoursesConfig import pd, nx, Network, OCGraphsIconsURL, math ,np, random, VizTemplate, VizFolder
import OCCoursesDatasets as ocd
from OCCoursesPlots import get_lighter_color, get_darker_color

# PyVis uses an old release of vis.js, with a bug referenced here: https://github.com/visjs/vis-network/issues/12
# I installed the bugfix version in the VizFolder (https://github.com/visjs/vis-network/pull/58)

# For plenty reasons, it easier to conceive textual unique ids for nodes, than natural-numbering them:
# - several dataframes may be joined to build the graph nodes and edges
# - the semantic of a textual ID is more human-understandable than a raw integer number
# However PyVis library needs interger unique ids to distinguish graph nodes.
# So let's build a little class doing the hash on demand
class AssociativeIdentifierArray:
    
    def __init__(self):
        self.counter=0
        self.object_dict=dict()
        self.numeric_dict=dict()
    #end function
    
    def get_counter(self):
        return self.counter
    
    def record_object_id(self,oid):
        numeric_id = self.object_dict.get(oid)
        if numeric_id is None:
            self.counter += 1
            self.object_dict[oid]=self.counter
            self.numeric_dict[self.counter]=oid
            return self.counter
        #end if
        return numeric_id
    # end method
    
    def record_object_id_array(self,obj_array):
        for o in obj_array:
            self.record_object_id(o)
        #end for
    # end method
    
    def contains_object_id(self,oid): 
        if self.object_dict.get(oid) is None:
            return False
        #end if
        return True
    # end method

    def contains_numeric_id(self, nid):
        if self.numeric_dict.get(nid) is None:
            return False
        #end if
        return True
    # end method   
    
    def get_object_dict(self):
        return self.object_dict
    # end method
    
    def get_numeric_dict(self):
        return self.object_dict
    # end method

    def get_object_id_for_numeric_id(self, nid):
        return int(self.numeric_dict.get(nid))
    # end method

    def get_numeric_id_for_object_id(self, oid):
        return self.object_dict.get(oid)
    # end method    
        
# end class

# tweak to have several graphs working in the same page
# the container in the PyVis html files is always named "mynetwork"
# we need to have unique distinct names to have several graphs on the same page
def rename_Network_container(container_name,filename):
    fin = open(filename, "rt")
    txt = fin.read()
    txt = txt.replace('mynetwork', container_name)
    fin.close()
    fin = open(filename, "wt")
    fin.write(txt)
    fin.close()
#end function

def mini_graph(text, height, width, bgcolor, font_color, directed,notebook,layout):
    g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout)
    g.add_node(0, "OpenClassrooms",group="root",color="#7451eb" ,shape="image", image=OCGraphsIconsURL["OpenClassrooms"],physics=False)
    g.add_node(1, text,group="root",color="font_color" ,title=text,shape="text", physics=True)
    color="#B491FE"
    g.add_edge(0, 1,hidden=False,color={'color':color, 'inherit':'false'})
    if (notebook==True):
        g.prep_notebook(custom_template=True, custom_template_path=VizTemplate)
    else:
        g.set_template(VizTemplate)
    return g
#end function

def empty_graph(height, width, bgcolor, font_color, directed,notebook,layout):
    g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout)
    g.add_node(0, "OpenClassrooms",group="root",color="#7451eb" ,shape="image", image=OCGraphsIconsURL["OpenClassrooms"],physics=False)
    g.add_node(1, "Nothing to show!",group="root",color="#C951eb" ,title="404 : Nothing found!",shape="text", physics=False)
    color="#B491FE"
    g.add_edge(0, 1,hidden=False,length=120,color={'color':color, 'inherit':'false'})
    if (notebook==True):
        g.prep_notebook(custom_template=True, custom_template_path=VizTemplate)
    else: 
        g.set_template(VizTemplate)
    return g
#end function

def allez_tous_en_cercle(index,numPoints,r):
    return r*math.cos((index*2*math.pi)/numPoints), r*math.sin((index*2*math.pi)/numPoints)

def build_topics_and_paths_graph(height='640px', width='99%',bgcolor="#ffffff",
                 font_color=False,heading=None,show_titles = True,directed=False,notebook=True,layout=False,show_buttons=False,filter_options=None): 
    
    magic_coeff=0.618
#     filter_options={
#          "height":paths_height_slider.value,
#         "topic":paths_topic_selector.value
#         "language":paths_language_selector.value
#         "level":paths_level_selector.value
#         "duration":paths_duration_selector.value
#     }
    if type(filter_options)!=type(None):
        height=str(filter_options["height"])+"px"
#     topic_filter=True
    
    # pick what we need
    dft=ocd.OC_Topics[["topic_id","topic_name"]]
     
    dfp=ocd.OC_Paths[["topic_id","path_id","path_title","path_language","path_level","path_duration_months","path_illustration"]].copy()
    if type(filter_options)!=type(None) and filter_options["topic"]!=0:
        dfp=dfp[dfp["topic_id"].isin([filter_options["topic"]])]
    if type(filter_options)!=type(None) and filter_options["language"]!="-":
        dfp=dfp[dfp["path_language"].isin([filter_options["language"]])]
    if type(filter_options)!=type(None) and filter_options["level"]!="-":
        dfp=dfp[dfp["path_level"].isin([filter_options["level"]])]
    if type(filter_options)!=type(None) and filter_options["duration"]!="-":
        dfp=dfp[dfp["path_duration_months"].isin([filter_options["duration"]])]
    
    if len(dfp) == 0:
        return empty_graph(height, width, bgcolor, font_color, directed,notebook,layout)
    
    dfp["path_grade"]=dfp['path_level'].map(ocd.path_grades)
    
    # merge the datasets
    dftp=dfp.merge(dft, on='topic_id', how='left').copy()
    
    # add unique ids and other columns for the graph
    dftp["topic_uid"]=dftp["topic_id"]
    dftp["topic_lang_uid"]=dftp.agg(lambda x: f"{x['topic_id']}-{x['path_language']}", axis=1)
    dftp["path_uid"]=dftp.agg(lambda x: f"{x['topic_id']}-{x['path_language']}-{x['path_id']}", axis=1)  
    
    # split the dataframe into nodes and edges
    topic_nodes=dftp[["topic_uid","topic_name"]].sort_values(by="topic_name").drop_duplicates()
    topic_nodes.columns = ["uid","label"]
    # display(topic_nodes)
    
    #.drop_duplicates()
    lang_nodes=dftp.sort_values(by=["topic_id","path_language"])[["topic_lang_uid","path_language"]].drop_duplicates()
    lang_nodes.columns = ["uid","label"]
    
    topic_lang_edges=dftp[["topic_uid","topic_lang_uid"]].drop_duplicates()
    topic_lang_edges.columns = ["src_uid","tgt_uid"]
    
    path_nodes=dftp[["path_uid","path_title","path_grade","path_duration_months","path_illustration"]].sort_values(by="path_grade").drop_duplicates()
    path_nodes.columns = ["uid","label","value","size","img"]
    path_nodes["size"]=path_nodes.agg(lambda x: f"{int(math.pow(x['size'],0.4)*(7+magic_coeff))}", axis=1)
    
    lang_path_edges=dftp[["topic_lang_uid","path_uid","path_duration_months"]].drop_duplicates()
    lang_path_edges["path_duration_months"]=dftp.agg(lambda x: f"{x['path_duration_months']}m", axis=1)
    lang_path_edges.columns = ["src_uid","tgt_uid","label"]
    
    # finally convert textual uids into a global numeric unique ids because PyVis doesn't like string ids 
    aia= AssociativeIdentifierArray()
    aia.record_object_id_array(topic_nodes.uid.values)
    aia.record_object_id_array(lang_nodes.uid.values)
    aia.record_object_id_array(path_nodes.uid.values)
    # display(aia.get_object_dict())
    topic_nodes["nid"]=topic_nodes["uid"].apply(aia.get_numeric_id_for_object_id)
    lang_nodes["nid"]=lang_nodes["uid"].apply(aia.get_numeric_id_for_object_id)
    path_nodes["nid"]=path_nodes["uid"].apply(aia.get_numeric_id_for_object_id)
    topic_lang_edges["src_nid"]=topic_lang_edges["src_uid"].apply(aia.get_numeric_id_for_object_id)   
    topic_lang_edges["tgt_nid"]=topic_lang_edges["tgt_uid"].apply(aia.get_numeric_id_for_object_id)    
    lang_path_edges["src_nid"]=lang_path_edges["src_uid"].apply(aia.get_numeric_id_for_object_id)                            
    lang_path_edges["tgt_nid"]=lang_path_edges["tgt_uid"].apply(aia.get_numeric_id_for_object_id)  
    
    g=None
    if (heading is None):
        g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout)
    else :
        g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout,heading=heading)
    g.toggle_physics(True)  
    
    
    if type(filter_options)!=type(None) and (filter_options["level"]!="-" or filter_options["topic"]!="-"):     
        physics_model="barneshut"   #="barneshut" / forceatlas
        if physics_model=="barneshut":
            g.barnes_hut(gravity=-10000,
                central_gravity=0.1,
                spring_length=150,
                spring_strength=0.02,
                damping=0.03,
                overlap=0.1)   
        elif physics_model=="forceatlas":
            g.force_atlas_2based(gravity=-400, 
                                 central_gravity=0.02, 
                                 spring_length=150, 
                                 spring_strength=0.08, 
                                 damping=0.4, 
                                 overlap=0.2) 
    else: 
        g.hrepulsion()
        
    # ------- ROOT NODE
    g.add_node(0, "OpenClassrooms",group="root",color="#7451eb" ,shape="image", image=OCGraphsIconsURL["OpenClassrooms"],mass=3,physics=False)
    
    # ------- TOPICS + edges to root
    first_nid=0
    previous_nid=0
    ray_root_topic=150+len(topic_nodes)*3
    counter=0
    for i,n in topic_nodes.iterrows():
        counter+=1
        topic_nid=int(n["nid"])
        topic_id=aia.get_object_id_for_numeric_id(topic_nid)
        nb_paths=len(dftp[dftp["topic_id"].isin([topic_id])]) 
        px , py = allez_tous_en_cercle(counter,len(topic_nodes),ray_root_topic)
        g.add_node(int(n["nid"]), ""+n["label"],size=25+nb_paths*magic_coeff, color="#9471fb",group="topic",
                   shape="image", image=OCGraphsIconsURL["topic"],physics=(len(topic_nodes) <4),x=px,y=py)
        g.add_edge(0, int(n["nid"]),length=ray_root_topic)
        if (previous_nid==0):
            previous_nid=int(n["nid"])
            first_nid=previous_nid
        else :
            if len(topic_nodes) >3:
                color="#B491FE"
                g.add_edge(previous_nid, int(n["nid"]),hidden=False,length=120,color={'color':color, 'inherit':'false'})
            previous_nid=int(n["nid"])
    if len(topic_nodes) >3:
        color="#B491FE"
        g.add_edge(previous_nid, first_nid,hidden=False,length=120,color={'color':color, 'inherit':'false'})
    
    
    # ------- LANG
    ray_topic_lang=int(80+10*math.sqrt(len(lang_nodes)))
    counter=0
    for i,n in lang_nodes.iterrows():
        counter+=1 
        px , py = allez_tous_en_cercle(counter,len(lang_nodes),ray_topic_lang*(1+magic_coeff))
        g.add_node(int(n["nid"]), n["label"],group="lang",size=16,color="#B491FE",shape="image", image=OCGraphsIconsURL[n["label"]],physics=True,x=px,y=py)
    
    # ------- TOPICS - LANG
    for i,e in topic_lang_edges.iterrows():
        topic_nid=int(e["src_nid"])
        topic_id=aia.get_object_id_for_numeric_id(topic_nid)
        nb_paths=len(dftp[dftp["topic_id"].isin([topic_id])])
        color="#B491FE"
        g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]), length=(ray_topic_lang*magic_coeff)+(nb_paths*(1+magic_coeff)*10), color={'color':color, 'inherit':'false'})     
    
    
    # ------- LANG WHEEL
    if len(topic_nodes) >3:
        ray_root_lang=ray_root_topic+ray_topic_lang
        lang_distance_iso=int((2*3.14*ray_root_lang)/len(lang_nodes))
    #     display(ray_root_topic,ray_topic_lang,ray_root_lang,lang_distance_iso,lang_distance_iso/12)
        lang_distance_iso= int(lang_distance_iso/3)# we want more distance between path clusters, and more density in the clusters

    #     print(ray_root_topic,ray_topic_lang,ray_root_lang,lang_distance_iso)
        for i,n in topic_nodes.iterrows():
            d=topic_lang_edges[topic_lang_edges["src_nid"].isin([n["nid"]])].sort_values(by="tgt_nid")
            previous_nid=0
            for j,e in d.iterrows():
                if (previous_nid==0):
                    previous_nid=int(e["tgt_nid"])
                else:
                    nid=int(e["tgt_nid"])
                    topic_nid=int(e["src_nid"])
                    topic_id=aia.get_object_id_for_numeric_id(topic_nid)
                    nb_paths=len(dftp[dftp["topic_id"].isin([topic_id])])
                    length=lang_distance_iso*magic_coeff*math.sqrt(nb_paths)
                    color="#B491FE"
                    g.add_edge(previous_nid, nid, hidden=False, length=length,title=str(length), color={'color':color, 'inherit':'false'}) 
                    previous_nid=nid
    
    # ------- PATHS
    for i,n in path_nodes.iterrows():
        ic = OCGraphsIconsURL["path_"+str(n["value"])]
        if (show_titles):
            g.add_node(int(n["nid"]), n["label"], title= n["uid"], size=int(n["size"]),group="path",shape="image", image=ic) 
        else:
            g.add_node(int(n["nid"]), n["label"], size=int(n["size"]),group="path",shape="image", image=ic) #value = int(n["value"]), 

    # ------- LANG - PATHS 
    for i,e in lang_path_edges.iterrows():
        color="#B491FE"
        g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=e["label"], color={'color':color, 'inherit':'false'})

            
    if (show_buttons):
        g.show_buttons(filter_="physics") 
    if (notebook==True):
        g.prep_notebook(custom_template=True, custom_template_path=VizTemplate)
    else: 
        g.set_template(VizTemplate)
    return g
#end function


zig_zag = "zag"
ga_bu_zo_meu="ga"
def climb_project_mountain(h,hmax,ymax,shape="mountain"):
    global zig_zag, ga_bu_zo_meu
    if shape=="mountain":
        return 3*h , (ymax/2)*(1 + math.cos((h*3.14/hmax)))
    elif  shape=="oc_wheel":
        min_h = 0
        max_h = hmax
        ray = ymax
        delta_h     = max_h-min_h
        min_theta   = -3*3.14/4 # 5*3.14/4
        max_theta   = 3*3.14/4
        delta_theta = max_theta - min_theta
        # the screen has y axix oriented downwards, so we must invert the rotation
        h=max_h-h
        theta       = min_theta + h*delta_theta/delta_h
        x = ray * math.cos(theta)
        y = ray * math.sin(theta)
        #plots=plots.append({"x": x,"y" : y}, ignore_index = True)
#         print(x,y)
        return x , y
    elif shape == "oc_stairzway":
        if zig_zag=="zig":
            zig_zag="zag"
            x = 3*h + 3*(hmax-h)/2
        else:
            zig_zag="zig"
            x = 3*h - 3*(hmax-h)/2
        y = (ymax/2)*(1 + math.cos((h*3.14/hmax)))
        return x,y
    elif shape=="shad_oc":
        xmax = 2*ymax
        ymax = 2*ymax
        if ga_bu_zo_meu=="ga":
            x = (xmax/2)-(xmax/2)*((hmax-h)/hmax)
            y = ymax-ymax*(h/hmax)
            ga_bu_zo_meu="bu"
        elif ga_bu_zo_meu=="bu":
            x = (xmax/2)+(xmax/2)*((hmax-h)/hmax)
            y = ymax-ymax*(h/hmax)
            ga_bu_zo_meu="zo"
        elif ga_bu_zo_meu=="zo":
            x = (xmax/2)+(xmax/2)*((hmax-h)/hmax)
            y = ymax-ymax*(h/hmax)
            ga_bu_zo_meu="meu"
        elif ga_bu_zo_meu=="meu":
            x = (xmax/2)-(xmax/2)*((hmax-h)/hmax)
            y = ymax-ymax*(h/hmax)
            ga_bu_zo_meu="ga"
        return x,y
    return 3*h , (ymax/2)*(1 + math.cos((h*3.14/hmax)))
# end function
 
# The relations src->tgt in the dataframe skeleton_edges are oriented with a parent > child semantics, 
# let P be a common ancestor of A and B 
# we calculate d(P,A) the number of nodes between P and A
# we calculate d(P,B) the number of nodes between P and B
# the parenthood degree D(A,B) = max(d(P,A),d(P,B))
def get_parenthood_degree_between(src_uid, tgt_uid,skeleton_edges,max_depth=20):
    # we want to know the parenthood degree of the nodes src and tgt
    # so we need to find a common ancestors of src and tgt, 
    # but of course we need to SKIP the link src->tgt during our computation
    # otherwise the parenthood degree would always be = 1
    depth=0
    common_parent_found=False
    set_a=set([src_uid])
    family_a=set([src_uid])
    set_b=set([tgt_uid])
    family_b=set([tgt_uid])
    # we do not want circular references
    edges = skeleton_edges[(skeleton_edges["src_uid"]!=skeleton_edges["tgt_uid"])].copy()
    # we look for ancestors of A , but we do not want to test links B->A and A->B
    edges = edges[~(edges["src_uid"].isin([src_uid]) & edges["tgt_uid"].isin([tgt_uid]))]
    edges = edges[~(edges["src_uid"].isin([tgt_uid]) & edges["tgt_uid"].isin([src_uid]))]
    
#     if (debug) :
#         print(" -------- "*5)
#         print(" ---------- --------------------- > start ",src_uid,tgt_uid)
    while (common_parent_found ==False) and (depth<max_depth):
        depth+=1
#         if (debug) :
#             print("step ",depth," A/ looking for parents of ",set_a)
            
        # we look for parents of A
        parents_a=set(edges[edges["tgt_uid"].isin(set_a)].src_uid.values)
        family_a=family_a | parents_a  
#         if (debug) :
#             print("---> parents = ",parents_a)
#             print("---> family = ",family_a)
#             print("step ",depth," B/ looking for parents of ",set_b)
        
        # we look for parents of B
        parents_b=set(edges[edges["tgt_uid"].isin(set_b)].src_uid.values)
        family_b=family_b | parents_b  
        
        
        common=family_a & family_b
#         if (debug):
#             print("---> parents = ",parents_b)
#             print("---> family = ",family_b)
#             print("step ",depth," intersection = ",common)

        if (len(common)>0):
            common_parent_found = True
#             if (debug):
#                 print(" ---------- > common ancestor found !")
            return depth,common

        new_a = parents_a - set_a
        new_b = parents_b - set_b
        if ((len(new_a) == 0) and (len(new_b) == 0)):
#             if (debug):
#                 print(" ---------- > nothing more to find !")
            return 0,{tgt_uid}
            break
        #else iterate
        set_a = parents_a
        set_b = parents_b
#         if (debug):
#             print(" ---------- > next")
    # end loop while no ancestor found
    return depth,{}
#end function 

def add_pseudo_nodes_between(g, aia, src_nid, tgt_nid, src_uid, tgt_uid, parenthood_floor, parenthood, color,show_titles):
    short_link=40
    long_link=450
    
    from_nid=src_nid
    to_nid=tgt_nid
    from_uid=src_uid
    to_uid=tgt_uid
    
    if (parenthood>3):
        uid="llink_from_"+str(from_uid)
        aia.record_object_id(uid) #will add a new object in the dictionary, except if it has already been added
        nid=aia.get_numeric_id_for_object_id(uid)
        title=None
        if (show_titles):
            title=str(parenthood)+" / "+uid
        g.add_node(nid,label=" ",group="longlink",mass=1,shape="dot",size=1,color=color)
        g.add_edge(from_nid,nid,length=short_link,color={'color':color, 'inherit':'false'},title=title) 
        from_nid=nid
        from_uid=uid
        

    uid="llink_to_"+str(to_uid)
    aia.record_object_id(uid) #will add a new object in the dictionary, except if it has already been added
    nid=aia.get_numeric_id_for_object_id(uid)
    title=None
    if (show_titles):
        title=uid
    g.add_node(nid,label=" ",group="longlink",mass=1,shape="dot",size=1,color=color,title=title)
    g.add_edge(nid,to_nid,length=short_link,color={'color':color, 'inherit':'false'},title=title)    
    to_nid=nid 
    to_uid=uid
        
    
    if parenthood > 6:  
        uid="llink_to_"+str(to_uid)
        aia.record_object_id(uid) #will add a new object in the dictionary, except if it has already been added
        nid=aia.get_numeric_id_for_object_id(uid)
        title=None
        if (show_titles):
            title=uid
        g.add_node(nid,label=" ",group="longlink",mass=1,shape="dot",size=1,color=color,title=title)
        g.add_edge(nid,to_nid,length=short_link,color={'color':color, 'inherit':'false'},title=title)    
        to_nid=nid     
        to_uid=uid
    
    
    edge_length=short_link
    if parenthood > 6:
        edge_length= long_link
    title=None
    if (show_titles):
        title="longlink_from_"+str(src_uid)+"_to_"+str(tgt_uid) 
    g.add_edge(from_nid,to_nid,length=edge_length,color={'color':color, 'inherit':'false'},title=title)  
#end function
        


    
# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------

def progress_status_to_progression(status):
    if status=="none":
        return 0
    elif status=="todo":
        return 0
    elif status=="in_progress":
        return 50
    elif status=="done":
        return 100
#end function

def progression_to_status(progression):
    status="none"
    if (type(progression)==type(None)):
        return "none"
    if (progression==np.nan):
        return "none"
    elif progression==0:
        return "todo"
    elif progression<100:
        return "in_progress"
    elif progression==100:
        return "done"
    return "none"
#end function

# parameters are named to avoid double negation
#    hide_links_towards_already_visited_courses => i_read_my_courses_once
#    hide_non_required_references => show_only_requirement_relations
#    hide_relations_over_parenthood_degree => show_relations_max_distance
def build_path_projects_courses_graph(path_id, max_depth=1, i_read_my_courses_once=True, show_only_requirement_relations = True,
                                      show_relations_max_distance=0,create_pseudo_nodes_over_max_distance=True, show_my_way = True,
                                      height='640px', width='99%',bgcolor="#ffffff",
                                      font_color=False,heading=None,shape="mountain", directed=False,notebook=True,layout=False,
                                      show_titles=True,show_buttons=False,filter_options=None):
    from OCCoursesGraphs import OCGraphsIconsURL
    global zig_zag, ga_bu_zo_meu 
#     filter_options={
#         "height"                             : projects_height_slider.value
#         "topic"                              : projects_topic_selector.value,
#         "path"                               : projects_path_selector.value,
#         "max_depth"                          : projects_max_depth_slider.value,
#         "i_read_my_courses_once"             : projects_ireadmycoursesonce_check.value,
#         "hide_references"                    : projects_hidereferences_check.value,
#         "relations_max_distance"             : projects_relations_max_distance_slider.value,
#         "pseudo_nodes"                       : projects_pseudonodes_check.value,
#         "mountain_shape"                     : projects_mountainshape_selector.value,
#         "show_my_way"                        : projects_myway_check.value
#     }
    
    if type(filter_options)!=type(None): 
        height=str(filter_options["height"])+"px"
        path_id = filter_options["path"]
        i_read_my_courses_once = filter_options["i_read_my_courses_once"]
        show_only_requirement_relations = filter_options["hide_references"]
        max_depth = filter_options["max_depth"]
        show_relations_max_distance = filter_options["relations_max_distance"]
        create_pseudo_nodes_over_max_distance = filter_options["pseudo_nodes"]
        show_my_way=filter_options["show_my_way"] 
#         shape options=[("Mountain",0),("OC Wheel",1),("StaiZway to OC",2),("Shad'OC Ladder GaBuZoMeu",3)],
        if filter_options["mountain_shape"]==0:
            shape = "mountain"
        elif filter_options["mountain_shape"]==1:
            shape = "oc_wheel"
        elif filter_options["mountain_shape"]==2:
            zig_zag="zag",
            shape = "oc_stairzway"
        elif filter_options["mountain_shape"]==3:
            ga_bu_zo_meu="ga"
            shape = "shad_oc"
        else :
            shape = "whatever"
    
    # ------------ create a skeleton dataframe to calculate distances between courses and projects
    skeleton_nodes=pd.DataFrame(columns=["uid","nid"])
    skeleton_nodes = skeleton_nodes.astype(dtype= {"uid":"object",
                                                   "nid":"int64"
                                                  })
    skeleton_edges=pd.DataFrame(columns=["src_uid","src_nid","relation","tgt_uid","tgt_nid","parenthood","parenthood_uid"])
    skeleton_edges = skeleton_edges.astype(dtype= {"src_uid":"object",
                                                   "src_nid":"int64",
                                                   "relation":"object",
                                                   "tgt_uid":"object",
                                                   "tgt_nid":"int64",
                                                   "parenthood":"int64",
                                                   "parenthood_uid":"object"
                                                  })
     
    # ------------ get the PATH
    dfpa= ocd.OC_Paths[ocd.OC_Paths["path_id"].isin([path_id])] # root
#     display(dfpa)

    # ------------ get the PROJECTS of the PATH
    dfpr= ocd.OC_Projects[ocd.OC_Projects["path_id"].isin([path_id])] # projects nodes
    dfpr=dfpr.merge(ocd.OC_MyProgressProjects,on=["path_id","project_number"],how="left")
    dfpr=dfpr.fillna(value={"status":"none"})
#     display(dfpr)

    # ------------ prepare MyProgressCourses
    dfoccourses=ocd.OC_Courses
    dfoccourses=dfoccourses.merge(ocd.OC_MyProgressCourses,on="course_id",how="left")
    dfoccourses["status"]=dfoccourses["progression"].apply(progression_to_status)
    
    # ------------ get the COURSES IMMEDIATELY REQUIRED FOR THE PROJECT
    dfpc= ocd.OC_ProjectsCoursesLinks[ocd.OC_ProjectsCoursesLinks["path_id"].isin([path_id])] # courses referenced/required by the project
    #     display(dfpc.head())

    #use sets to have unique courses IDs and avoid counting the same courses twice or more
    courses = set(dfpc.course_id.values)
    
#     display(courses)

    # ------------ get ALL the COURSES LINKED TO PROJECT COURSES TRANSITIVELY
    # now get all courses linked 
#     display(ocd.OC_CoursesLinks_cols)
    #keep an array of transitive closure steps
    courses_layers=[courses]
    depth=0
    linked_courses_found=True
    while linked_courses_found and depth<max_depth:
        linked_courses_found = False
        depth+=1
        df=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(courses)) & ~(ocd.OC_CoursesLinks["tgt_course_id"].isin([0]))]
        tgt_courses=set(df.tgt_course_id.values) - courses
#         print("--->",len(tgt_courses)," courses linked to previous courses")
    #     display(df)
        #now iterate
        if (len(tgt_courses)>0):
            linked_courses_found = True
            courses_layers.append(tgt_courses)
            courses=courses | tgt_courses
#             print("--->--->",len(courses)," courses in the full transitive closure")
    # end while 
    #display(courses)
    dfc=dfoccourses[dfoccourses["course_id"].isin(courses)]
    
#     print(len(dfc)," in the full transitive closure set")
#     display(dfc)
    dfcc=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(courses)) & (ocd.OC_CoursesLinks["tgt_course_id"].isin(courses))].drop_duplicates(subset=["src_course_id","tgt_course_id","relation"])

#     # weird : len(dfc) is not equal to len(courses)
#     # something todo later : resolve broken links due to archived courses, redirections to new courses ...
#     full_courses = set(dfc.course_id.values)
#     diff_courses = courses - full_courses
#     print("there are ",len(diff_courses)," courses in the full transitive closure that were not found in the courses dataset :")
#     display(diff_courses)
    
    # ------------------ OK NOW BUILD A GRAPH WITH dfpa, dfpr, dfpc and dfc nodes
    
    # pick what we need 
    #paths
    dfpa=dfpa[["topic_id","path_id","path_title","path_language","path_level","path_duration_months","path_illustration"]].copy()
    #projects
    dfpr=dfpr[["path_id","project_number","project_title","project_description","project_duration_hours","status"]].sort_values(by="project_number").copy()
    #projects-courses edges
    
    dfpc=dfpc.merge(dfoccourses, on='course_id', how='left')
    dfpc=dfpc[['path_id','project_number','course_id','course_title','course_difficulty','course_duration_hours','course_url','status']].copy()
    #courses
    dfc=dfc[['topic_id','course_id','course_title','course_difficulty','course_duration_hours','course_url','status']].copy()
    #courses-courses edges
    #display(dfcc[dfcc.duplicated(subset=["src_course_id","tgt_course_id","relation"],keep=False)])
    dfcc=dfcc.merge(dfoccourses, left_on='src_course_id', right_on='course_id', how='left')
    dfcc=dfcc[['src_course_id','relation', 'tgt_course_id','course_title','course_url','course_difficulty','course_duration_hours','status']].copy ()
    dfcc.columns=['src_course_id','relation', 'tgt_course_id','src_course_title','src_course_url','src_course_difficulty','src_course_duration_hours','src_status']
    dfcc=dfcc.merge(dfoccourses, left_on='tgt_course_id', right_on='course_id', how='left')
    dfcc=dfcc[['src_course_id','relation', 'tgt_course_id','src_course_title','src_course_url','src_course_difficulty','src_course_duration_hours','src_status','course_title','course_url','course_difficulty','course_duration_hours','status']].copy ()
    dfcc.columns=['src_course_id','relation', 'tgt_course_id','src_course_title','src_course_url','src_course_difficulty','src_course_duration_hours','src_status','tgt_course_title','tgt_course_url','tgt_course_difficulty','tgt_course_duration_hours','tgt_status']
    # add unique ids and other columns for the graph
    dfpa["uid"]=dfpa["path_id"]
    
    dfpr["path_uid"]=dfpr["path_id"]
    dfpr["uid"]=dfpr.agg(lambda x: f"{x['path_id']}-{x['project_number']}", axis=1)
    
    dfpc["src_uid"]=dfpc.agg(lambda x: f"{x['path_id']}-{x['project_number']}", axis=1)
    dfpc["tgt_uid"]=dfpc.agg(lambda x: f"c_{x['course_id']}", axis=1)
    dfpc["course_difficulty_grade"]=dfpc['course_difficulty'].map(ocd.course_grades)
    
    dfc["uid"]=dfc.agg(lambda x: f"c_{x['course_id']}", axis=1)
    dfc["course_difficulty_grade"]=dfc['course_difficulty'].map(ocd.course_grades)
    
    dfcc["src_uid"]=dfcc.agg(lambda x: f"c_{x['src_course_id']}", axis=1)
    dfcc["tgt_uid"]=dfcc.agg(lambda x: f"c_{x['tgt_course_id']}", axis=1)
    dfcc["src_course_difficulty_grade"]=dfcc['src_course_difficulty'].map(ocd.course_grades)
    dfcc["tgt_course_difficulty_grade"]=dfcc['tgt_course_difficulty'].map(ocd.course_grades)
    
    # convert textual uids into a global numeric unique ids because PyVis doesn't like string ids 
    aia= AssociativeIdentifierArray()
    aia.record_object_id_array(dfpa.uid.values)
    aia.record_object_id_array(dfpr.uid.values)
    aia.record_object_id_array(dfc.uid.values)
    aia.record_object_id_array(dfcc.src_uid.values)
    aia.record_object_id_array(dfcc.tgt_uid.values)
    # display(aia.get_object_dict())
    dfpa["nid"]=dfpa["uid"].apply(aia.get_numeric_id_for_object_id)
    dfpr["nid"]=dfpr["uid"].apply(aia.get_numeric_id_for_object_id)
    dfpr["path_nid"]=dfpr["path_uid"].apply(aia.get_numeric_id_for_object_id)
    dfc["nid"]=dfc["uid"].apply(aia.get_numeric_id_for_object_id)
    dfpc["src_nid"]=dfpc["src_uid"].apply(aia.get_numeric_id_for_object_id)
    dfpc["tgt_nid"]=dfpc["tgt_uid"].apply(aia.get_numeric_id_for_object_id)
    dfcc["src_nid"]=dfcc["src_uid"].apply(aia.get_numeric_id_for_object_id)
    dfcc["tgt_nid"]=dfcc["tgt_uid"].apply(aia.get_numeric_id_for_object_id)
    
    # build the graph nodes
    if type(heading) == type(None) :
        g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout)
    else : 
        g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout,heading=heading)
    g.toggle_physics(True) 
    oc_colors=["#7451eb","#9471fb","#B491FE"]
    path_color="#7451eb"
    project_color="#5451db"
    course_color="#B491FE"
    link_colors={
        "primary_requires"    : "#2D2", # the requirement links between a project and courses
        "primary_references"  : "#22D", # the "other" links between a project and courses (the list is empty but we have a color for that :) )
        "secundary_requires"  : "#8C2", # the requirement links between courses of depth D to depth D+1
        "secundary_references": "#82C", # the other links between courses of depth D to depth D+1
        "tertiary_requires"   : "#DB2", #the requirement links between courses of depth D to any depth other than D+1
        "tertiary_references" : "#D2B", # the other links between courses of depth D to any depth other than D+1
        "long_link"           : "#BB8", # the other long distance links
    }
    g.barnes_hut(gravity=-8000,
        central_gravity=0.1,
        spring_length=140,
        spring_strength=0.05,
        damping=0.03,
        overlap=0)    
    
    path = next(dfpa[dfpa["path_id"].isin([path_id])].iterrows())[1]
    
    # let's place projects on a sinusoid
    # I could empirically get the good formula thanks to https://www.desmos.com/calculator?lang=fr
    ymax=800
    if (shape=="mountain"):
        ymax=2000 
    hmax=dfpr.project_duration_hours.sum()+100 # keep 100 for the last 2 nodes  
    ph=0
    px , py = climb_project_mountain(ph,hmax,ymax,shape)
    plength=180
    
    # --------- PATH
    if (show_titles):
        g.add_node(path["nid"], path["path_title"],group="root",color=path_color ,shape="image", image=OCGraphsIconsURL["path"], physics=False,x=px,y=py,title=str(path["path_title"]))
    else:
        g.add_node(path["nid"], path["path_title"],group="root",color=path_color ,shape="image", image=OCGraphsIconsURL["path"], physics=False,x=px,y=py)
    # skeleton_nodes = skeleton_nodes.append({"uid": path["uid"],"nid" : path["nid"]}, ignore_index = True)
    skeleton_nodes = pd.concat([skeleton_nodes,pd.DataFrame([{"uid": path["uid"],"nid" : path["nid"]}])],ignore_index=True)
    # ---------- PROJECTS IN A MOUNTAIN
    previous_uid=0
    previous_nid=0
    for i,n in dfpr.iterrows():
        length = plength+ n["project_duration_hours"]
        ph+=n["project_duration_hours"]
        px , py = climb_project_mountain(ph,hmax,ymax,shape)
        #py+=plength*random.random()-int(plength/2)
        image=OCGraphsIconsURL["project"]
        if (show_my_way==True):
            status=n["status"]
            if (status!="none"):
                image=OCGraphsIconsURL["project"+"_"+status]
            
        if (show_titles):
            g.add_node(int(n["nid"]), str(n["project_number"])+"-"+n["project_title"], color=project_color,group="project",shape="image",\
                       image=image,physics=False,x=px,y=py,title=str(path["path_title"])+" / "+str(n["project_title"]))
        else:
            g.add_node(int(n["nid"]), str(n["project_number"])+"-"+n["project_title"], color=project_color,group="project",shape="image",\
                       image=image,physics=False,x=px,y=py)
        #skeleton_nodes.append([n["uid"],n["nid"]]) #???
        #skeleton_nodes = skeleton_nodes.append({"uid": n["uid"],"nid" : n["nid"]}, ignore_index = True)
        skeleton_nodes = pd.concat([skeleton_nodes,pd.DataFrame([{"uid": n["uid"],"nid" : n["nid"]}])],ignore_index=True)

        if (previous_nid==0):
            g.add_edge(path["nid"], int(n["nid"]),label=str(n["project_duration_hours"])+"h")
            #skeleton_edges = skeleton_edges.append({"src_uid": path["uid"],"src_nid" : path["nid"],"relation":"precedes","tgt_uid":n["uid"],"tgt_nid":n["nid"]}, ignore_index = True)
            skeleton_edges = pd.concat([skeleton_edges,pd.DataFrame([{"src_uid": path["uid"],"src_nid" : path["nid"],"relation":"precedes","tgt_uid":n["uid"],"tgt_nid":n["nid"]}])],ignore_index=True)
            previous_uid=n["uid"]
            previous_nid=int(n["nid"])
        else :
            g.add_edge(previous_nid, int(n["nid"]),label=str(n["project_duration_hours"])+"h") #,hidden=True 
            # skeleton_edges = skeleton_edges.append({"src_uid": previous_uid,"src_nid" : previous_nid,"relation":"precedes","tgt_uid":n["uid"],"tgt_nid":n["nid"]}, ignore_index = True)
            skeleton_edges = pd.concat([skeleton_edges,pd.DataFrame([{"src_uid": previous_uid,"src_nid" : previous_nid,"relation":"precedes","tgt_uid":n["uid"],"tgt_nid":n["nid"]}])],ignore_index=True)
            previous_uid=n["uid"]
            previous_nid=int(n["nid"])
    
    ph+=70
    px , py = climb_project_mountain(ph,hmax,ymax,shape) 
    last_nid=aia.record_object_id(str(path_id)+"-jury")
    g.add_node(last_nid, "jury", color=project_color,group="project",shape="image", image=OCGraphsIconsURL["project_jury"],physics=False,x=px,y=py)
    g.add_edge(previous_nid, last_nid,length=50) #,hidden=True
    ph+=30
    px , py = climb_project_mountain(ph,hmax,ymax,shape)
    last_nid=aia.record_object_id(str(path_id)+"-Bravo")
    g.add_node(last_nid, "Bravo!", color=project_color,group="project",shape="image", image=OCGraphsIconsURL["project_success"],physics=False,x=px,y=py)
    g.add_edge(last_nid-1, last_nid,length=50) #,hidden=True
            
    # ---------- COURSES
    # we do not add courses from the dataframe "dfc" because some of them should not be shown on the graph due to edge-cutting optimization
    # for now let us "just" complete the skeleton
    for i,n in dfc.iterrows():
        # skeleton_nodes = skeleton_nodes.append({"uid": n["uid"],"nid" : n["nid"]}, ignore_index = True)
        skeleton_nodes = pd.concat([skeleton_nodes,pd.DataFrame([{"uid": n["uid"],"nid" : n["nid"]}])],ignore_index=True)
    

    # ---------- LINKING PROJECTS TO COURSES
    #     display(dfpc)
    
    already_visited_courses=[]
    # adding layer 0 of courses_layers
    for i,e in dfpc.iterrows():
        #skeleton_edges = skeleton_edges.append({"src_uid": e["src_uid"],"src_nid" : e["src_nid"],"relation":"project_requires","tgt_uid":e["tgt_uid"],"tgt_nid":e["tgt_nid"]}, ignore_index = True)
        skeleton_edges = pd.concat([skeleton_edges,pd.DataFrame([{"src_uid": e["src_uid"],"src_nid" : e["src_nid"],"relation":"project_requires","tgt_uid":e["tgt_uid"],"tgt_nid":e["tgt_nid"]}])],ignore_index=True)
        if (i_read_my_courses_once and  e["course_id"] in already_visited_courses):
                continue
        else :
            image=OCGraphsIconsURL["course"]
            if (show_my_way==True):
                status=e["status"]
                if (status!="none"):
                    image=OCGraphsIconsURL["course"+"_"+status]
            if (show_titles):
                g.add_node(int(e["tgt_nid"]), e["course_title"], size=e["course_difficulty_grade"]*10,\
                           color=course_color,shape="image", image=image,
                           title="<a href=\""+e["course_url"]+"\" target=\"_blank\">"+e["course_title"]+"</a>")
            else : 
                g.add_node(int(e["tgt_nid"]), e["course_title"], size=e["course_difficulty_grade"]*10,\
                           color=course_color,shape="image", image=image) 
            length = plength+ e["course_duration_hours"]
            g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(int(e["course_duration_hours"]))+"h",color={'color':link_colors["primary_requires"], 'inherit':'false'},title="1st req")    
            already_visited_courses.append(e["course_id"])
        
        
    # attention, il y a des liens cassés car des cours connus par leur lien sont introuvables dans la liste des cours
#     display(dfcc)

    # ------------ LINKING COURSES TO COURSES
    
    # complete the skeleton with all links
    for i,e in dfcc.iterrows():
        # avoid self-references in the graph
        if (e["src_nid"]==e["tgt_nid"]):
            continue
        # skeleton_edges = skeleton_edges.append({"src_uid": e["src_uid"],"src_nid" : e["src_nid"],"relation":e["relation"],"tgt_uid":e["tgt_uid"],"tgt_nid":e["tgt_nid"]}, ignore_index = True)
        skeleton_edges = pd.concat([skeleton_edges,pd.DataFrame([{"src_uid": e["src_uid"],"src_nid" : e["src_nid"],"relation":e["relation"],"tgt_uid":e["tgt_uid"],"tgt_nid":e["tgt_nid"]}])],ignore_index=True)
    
    # compute parenthoods in the skeleton graph
    #skeleton_edges.agg(lambda x: get_parenthood_degree_between(x['src_uid'],x['tgt_uid'],skeleton_edges), axis=1) 
    skeleton_edges["parenthood"] = -1
    skeleton_edges["parenthood_uid"] = "{}"
    skeleton_edges = skeleton_edges.astype(dtype= {"src_uid":"object",
                                                   "src_nid":"int64",
                                                   "relation":"object",
                                                   "tgt_uid":"object",
                                                   "tgt_nid":"int64",
                                                   "parenthood":"int64",
                                                   "parenthood_uid":"object"
                                                  }) 
#     display("skeleton_edges",skeleton_edges)    
#     display("dans dfcc mais pas dans skeleton_edges",dfcc[~(dfcc["src_uid"].isin(skeleton_edges.src_uid.values)  & dfcc["tgt_uid"].isin(skeleton_edges.tgt_uid.values))])    
#     display("dans skeleton_edges mais pas dans dfcc", skeleton_edges[~(skeleton_edges["src_uid"].isin(dfcc.src_uid.values)  & skeleton_edges["tgt_uid"].isin(dfcc.tgt_uid.values))])
#     display(dfcc.head(30))
    newvalues=[]
    for i,e in skeleton_edges.iterrows():
        if (skeleton_edges.loc[i,"parenthood"]==-1):
            p, n = get_parenthood_degree_between(e['src_uid'],e['tgt_uid'],skeleton_edges) 
            newvalues.append([i,p,str(n)])
    for r in newvalues:
        skeleton_edges.at[r[0],'parenthood'] = r[1]
        skeleton_edges.at[r[0],"parenthood_uid"]=r[2]
            
    dfccm = dfcc.merge(skeleton_edges[["src_uid","tgt_uid","parenthood","parenthood_uid"]],on=["src_uid","tgt_uid"],how="left") 
#     display("skeleton_edges après calcul de parenté",skeleton_edges)  
#     display("dfccm = dfcc left join skeleton_edges", dfccm)    
    
#     display("before",aia.get_object_dict())
    # now deal with courses, starting from project courses layer, then going from layer to layer
    #iterate over the courses layers to build parent-child relations
    # avoid showing new links towards courses that were previously linked to some nodes in the graph
    # it is a pedagogical optimization, and it reduces the complexity of dependencies resolution, 
    # but it has some drawbacks : how do we know if a course is referenced at the proper moment in the graph
    # edges should be sorted from project 1 to project N
    already_added_relations=[]
    #display(courses_layers)
    previous_layer=set()
    # we add nodes and edges, layer per layer, starting at layer 1 because layer 0 was added above
    for depth in range(1,len(courses_layers)):
        previous_layer=courses_layers[depth-1]
        cset=courses_layers[depth]
        # first add edges with relation "requires"
        for i,e in dfccm[dfccm["src_course_id"].isin(previous_layer) & dfccm["tgt_course_id"].isin(cset)].dropna().iterrows(): 
            if (e["parenthood"]>show_relations_max_distance and create_pseudo_nodes_over_max_distance==False):
                continue
            if (e["relation"]!="requires"):
                continue 
            if (i_read_my_courses_once and  e["tgt_course_id"] in already_visited_courses):
                continue
            else :
                already_visited_courses.append(e["tgt_course_id"])
            color=link_colors["secundary_requires"]
            
            srcimage=OCGraphsIconsURL["course"]
            tgtimage=OCGraphsIconsURL["course"]
            if (show_my_way==True):
                srcstatus=e["src_status"]
                tgtstatus=e["tgt_status"]
                if (srcstatus!="none"):
                    srcimage=OCGraphsIconsURL["course"+"_"+srcstatus]
                if (tgtstatus!="none"):
                    tgtimage=OCGraphsIconsURL["course"+"_"+tgtstatus]
            if (show_titles):
                g.add_node(int(e["src_nid"]), e["src_course_title"], size=e["src_course_difficulty_grade"]*10,group="course",\
                           color=course_color,shape="image", image=srcimage,\
                           title="<a href=\""+e["src_course_url"]+"\" target=\"_blank\">"+e["src_course_title"]+"</a>")
                g.add_node(int(e["tgt_nid"]), e["tgt_course_title"], size=e["tgt_course_difficulty_grade"]*10,group="course",\
                           color=course_color,shape="image", image=tgtimage,\
                           title="<a href=\""+e["tgt_course_url"]+"\" target=\"_blank\">"+e["tgt_course_title"]+"</a>")
            else : 
                g.add_node(int(e["src_nid"]), e["src_course_title"], size=e["src_course_difficulty_grade"]*10,group="course",\
                           color=course_color,shape="image", image=srcimage)
                g.add_node(int(e["tgt_nid"]), e["tgt_course_title"], size=e["tgt_course_difficulty_grade"]*10,group="course",\
                           color=course_color,shape="image", image=tgtimage) 
            if (e["parenthood"]>show_relations_max_distance and create_pseudo_nodes_over_max_distance==True):
                #create smthng
#                 print("adding longlink ", int(e["parenthood"]), e["src_course_title"],int(e["src_nid"]), e["tgt_course_title"], int(e["tgt_nid"]))
                add_pseudo_nodes_between(g,aia,int(e["src_nid"]), int(e["tgt_nid"]), e["src_uid"],\
                                         e["tgt_uid"],show_relations_max_distance,int(e["parenthood"]),\
                                         color=link_colors["long_link"],show_titles=show_titles)
            else:
                edge_title = "2nd req / "+str(int(e["parenthood"]))+" : "+str(e["parenthood_uid"])
                g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(int(e["tgt_course_duration_hours"]))+"h",\
                           color={'color':color, 'inherit':'false'},title=edge_title)  
            already_added_relations.append((int(e["src_nid"]), int(e["tgt_nid"])))

        # then add edges with relation other than "requires"
        if (show_only_requirement_relations==False):  
            for i,e in dfccm[dfccm["src_course_id"].isin(previous_layer) & dfccm["tgt_course_id"].isin(cset)].dropna().iterrows(): 
                if (e["parenthood"]>show_relations_max_distance and create_pseudo_nodes_over_max_distance==False):
                    continue
                if (e["relation"]=="requires"):
                    continue 
                if (i_read_my_courses_once and  e["tgt_course_id"] in already_visited_courses):
                    continue
                else :
                    already_visited_courses.append(e["tgt_course_id"])  
                color=link_colors["secundary_references"] 
                srcimage=OCGraphsIconsURL["course"]
                tgtimage=OCGraphsIconsURL["course"]
                if (show_my_way==True):
                    srcstatus=e["src_status"]
                    tgtstatus=e["tgt_status"]
                    if (srcstatus!="none"):
                        srcimage=OCGraphsIconsURL["course"+"_"+srcstatus]
                    if (tgtstatus!="none"):
                        tgtimage=OCGraphsIconsURL["course"+"_"+tgtstatus]
                if (show_titles):
                    g.add_node(int(e["src_nid"]), e["src_course_title"], size=e["src_course_difficulty_grade"]*10,group="course",\
                               color=course_color,shape="image", image=srcimage,\
                               title="<a href=\""+e["src_course_url"]+"\" target=\"_blank\">"+e["src_course_title"]+"</a>")
                    g.add_node(int(e["tgt_nid"]), e["tgt_course_title"], size=e["tgt_course_difficulty_grade"]*10,group="course",\
                               color=course_color,shape="image", image=tgtimage,\
                               title="<a href=\""+e["tgt_course_url"]+"\" target=\"_blank\">"+e["tgt_course_title"]+"</a>")
                else : 
                    g.add_node(int(e["src_nid"]), e["src_course_title"], size=e["src_course_difficulty_grade"]*10,group="course",\
                               color=course_color,shape="image", image=srcimage)
                    g.add_node(int(e["tgt_nid"]), e["tgt_course_title"], size=e["tgt_course_difficulty_grade"]*10,group="course",\
                               color=course_color,shape="image", image=tgtimage) 
                if (e["parenthood"]>show_relations_max_distance and create_pseudo_nodes_over_max_distance==True):
                    #create smthng
#                     print("adding longlink ", int(e["parenthood"]), e["src_course_title"],int(e["src_nid"]), e["tgt_course_title"], int(e["tgt_nid"]))
                    add_pseudo_nodes_between(g,aia,int(e["src_nid"]), int(e["tgt_nid"]), e["src_uid"], e["tgt_uid"],show_relations_max_distance,int(e["parenthood"]),color=link_colors["long_link"],show_titles=show_titles)
                else:
                    edge_title = "2nd ref / "+str(int(e["parenthood"]))+" : "+str(e["parenthood_uid"])
                    g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(int(e["tgt_course_duration_hours"]))+"h",color={'color':color, 'inherit':'false'},title=edge_title)
                already_added_relations.append((int(e["src_nid"]), int(e["tgt_nid"])))
        # end if we show 'non required' references 
    #end loop over courses_layers
    

    # finally add the other edges 
    # - between members of the same depth (layer) : brothers, cousins, ... far cousins
    # - or between members of more distant layers
    # the parameter show_relations_max_distance allows to keep close relationships visible
    for i,e in dfccm.dropna().iterrows():
        # avoid self-references in the graph
        if (e["src_nid"]==e["tgt_nid"]):
            continue
        if (e["parenthood"]>show_relations_max_distance and create_pseudo_nodes_over_max_distance==False):
                continue
        if (i_read_my_courses_once and  e["tgt_course_id"] in already_visited_courses):
            continue
        if (int(e["src_nid"]), int(e["tgt_nid"])) in already_added_relations:
            continue
        color=link_colors["tertiary_requires"]
        edge_title="3rd req"
        if (e["relation"]!="requires"):
            if show_only_requirement_relations:
                continue
            color=link_colors["tertiary_references"]
            edge_title="3rd ref" 
        edge_title += " / "+str(int(e["parenthood"]))+" : "+str(e["parenthood_uid"])
        already_visited_courses.append(e["src_course_id"])
        already_visited_courses.append(e["tgt_course_id"])
        srcimage=OCGraphsIconsURL["course"]
        tgtimage=OCGraphsIconsURL["course"]
        if (show_my_way==True):
            srcstatus=e["src_status"]
            tgtstatus=e["tgt_status"]
            if (srcstatus!="none"):
                srcimage=OCGraphsIconsURL["course"+"_"+srcstatus]
            if (tgtstatus!="none"):
                tgtimage=OCGraphsIconsURL["course"+"_"+tgtstatus]
        if (show_titles):
            g.add_node(int(e["src_nid"]), e["src_course_title"], size=e["src_course_difficulty_grade"]*10,group="course",\
                       color=course_color,shape="image", image=srcimage,\
                       title="<a href=\""+e["src_course_url"]+"\" target=\"_blank\">"+e["src_course_title"]+"</a>")
            g.add_node(int(e["tgt_nid"]), e["tgt_course_title"], size=e["tgt_course_difficulty_grade"]*10,group="course",\
                       color=course_color,shape="image", image=tgtimage,\
                       title="<a href=\""+e["tgt_course_url"]+"\" target=\"_blank\">"+e["tgt_course_title"]+"</a>")
        else : 
            g.add_node(int(e["src_nid"]), e["src_course_title"], size=e["src_course_difficulty_grade"]*10,group="course",\
                       color=course_color,shape="image", image=srcimage)
            g.add_node(int(e["tgt_nid"]), e["tgt_course_title"], size=e["tgt_course_difficulty_grade"]*10,group="course",\
                       color=course_color,shape="image", image=tgtimage)  
        if (e["parenthood"]>show_relations_max_distance and create_pseudo_nodes_over_max_distance==True):
            #create smthng
#             print("adding longlink ", int(e["parenthood"]), e["src_course_title"],int(e["src_nid"]), e["tgt_course_title"], int(e["tgt_nid"]))
            add_pseudo_nodes_between(g,aia,int(e["src_nid"]), int(e["tgt_nid"]), e["src_uid"], e["tgt_uid"],show_relations_max_distance,int(e["parenthood"]),color=link_colors["long_link"],show_titles=show_titles)
        else:
            g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(int(e["tgt_course_duration_hours"]))+"h",color={'color':color, 'inherit':'false'},title=edge_title) 
        already_added_relations.append((int(e["src_nid"]), int(e["tgt_nid"])))
    # end if we don't hide    
    
#     print(skeleton_edges)
#     display(skeleton_edges.tail(30))
#     display("after",aia.get_object_dict())
    # finally animate and export the graph
        
    if (show_buttons):
        g.show_buttons(filter_="physics") 
    if (notebook==True):
        g.prep_notebook(custom_template=True, custom_template_path=VizTemplate)
    else: 
        g.set_template(VizTemplate)
    return g
#end function


# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# the following function is focused on the courses graph.
# if topic_id is selected (not equal to 0), only courses belonging to this topic will be shown
# if language is selected (not equal to '-'), only courses belonging to this language will be shown
#
# In this courses graph, paths are shown as a vertebral structure underlying the courses network. 
# Each path is shown as a single node, except if path_is non zero (the path is then shown as a sequence of projects).
# if path_topic_id is selected (not equal to 0), only paths belonging to this topic will be shown
# if path_language is selected (not equal to '-'), only paths belonging to this language will be shown
# If path_id is selected (not equal to 0), only the path structure of this path will be shown
#
# if connex_paths is True, only the courses connected to the selected paths will be shown
def build_courses_graph(topic_id=0,language='-',path_topic_id=0,path_language='-',\
                        path_id=0,max_depth=20,show_my_way=True,show_only_requirement_relations = True,connex_paths=False,\
                        atlas_layout=False,height='640px', width='99%',palette="Topic", bgcolor="#ffffff",\
                        font_color=False,heading=None,directed=True,notebook=True,layout=False,\
                        show_titles=True,show_buttons=False,filter_options=None):
    
#     filter_options={
#         "height"                             : courses_height_slider.value,
#         "topic"                              : courses_topic_selector.value,
#         "language"                               : courses_language_selector.value,
#         "path_topic"                         : courses_path_topic_selector.value,
#         "path_language"                      : courses_path_language_selector.value,
#         "max_depth"                          : courses_max_depth_slider.value,
#         "path"                               : courses_path_selector.value, 
#         "hide_references"                    : courses_hidereferences_check.value,
#         "atlas_layout"                       : courses_algo_check.value,
#         "show_my_way"                        : courses_myway_check.value, 
#         "palette"                            : courses_palette_selector.value,
#         "connex_paths"                       : courses_connexpaths_check.value
#     }
#     show_buttons=True
    if type(filter_options)!=type(None): 
        height=str(filter_options["height"])+"px"
        palette = filter_options["palette"] 
        topic_id = filter_options["topic"] 
        language=filter_options["language"] 
        path_topic_id = filter_options["path_topic"] 
        path_language=filter_options["path_language"] 
        path_id = filter_options["path"] 
        max_depth= filter_options["max_depth"] 
        atlas_layout=filter_options["atlas_layout"] 
        show_my_way= filter_options["show_my_way"] 
        show_only_requirement_relations = filter_options["hide_references"] 
        connex_paths=filter_options["connex_paths"] 
#     display(filter_options)
#     display(height,language,path_id,topic_id)
    # ------------ get the PATH
    if (path_id==0):#get all paths
        dfpa= ocd.OC_Paths
    else:
        dfpa= ocd.OC_Paths[ocd.OC_Paths["path_id"].isin([path_id])]
    if (path_topic_id!=0):
        dfpa= dfpa[dfpa["topic_id"].isin([path_topic_id])] 
    if (path_language!='-'):
        dfpa= dfpa[dfpa["path_language"].isin([path_language])] 
    
    dfpa=dfpa.merge(ocd.OC_Topics[["topic_id","topic_color"]],on="topic_id",how="left")
    
    # ------------ get the PROJECTS of the PATH(s)
    dfpr= ocd.OC_Projects[ocd.OC_Projects["path_id"].isin(dfpa.path_id.unique())] # projects nodes
    dfpr=dfpr.merge(ocd.OC_Paths[["path_id","topic_id"]],on="path_id",how="left")
    dfpr=dfpr.merge(ocd.OC_Topics[["topic_id","topic_color"]],on="topic_id",how="left")

    # ------------ get the COURSES relevant for the filter
    dfc=ocd.OC_Courses
    if (topic_id!=0):
        dfc= dfc[dfc["topic_id"].isin([topic_id])] 
    if (language!='-'):
        dfc= dfc[dfc["course_language"].isin([language])] 
    dfc=dfc.merge(ocd.OC_Topics[["topic_id","topic_color"]],on="topic_id",how="left")  
    dfc=dfc.merge(ocd.OC_MyProgressCourses,on="course_id",how="left")
    dfc["status"]=dfc["progression"].apply(progression_to_status)
    
    filter_courses = set(dfc.course_id.unique())
    
    # ------------ get the COURSES IMMEDIATELY REQUIRED FOR THE PROJECTs and relevant for the filter
    dfpc= ocd.OC_ProjectsCoursesLinks[ocd.OC_ProjectsCoursesLinks["path_id"].isin(dfpa.path_id.unique()) &\
                                      ocd.OC_ProjectsCoursesLinks["course_id"].isin(filter_courses)] # courses referenced/required by the project
    
    # ----------- get the COURSES INDIRECTLY CONNECTED FOR THE PROJECTs (and relevant for the filter)
        
    # build an array of layers of courses, starting from the paths project courses, and iterating to max_depth 
    #use sets to have unique courses IDs and avoid counting the same courses twice or more
    path_courses = set(dfpc.course_id.unique())
    courses_layers=[path_courses] 
    depth=0 
    linked_courses_found=True
    while linked_courses_found and depth<max_depth:
        linked_courses_found = False
        depth+=1
        if (show_only_requirement_relations):
            df=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(path_courses)) &\
                                   (ocd.OC_CoursesLinks["tgt_course_id"].isin(filter_courses)) &\
                                   (ocd.OC_CoursesLinks["relation"].isin(["requires"])) &\
                                   ~(ocd.OC_CoursesLinks["tgt_course_id"].isin([0]))]
        else:
            df=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(path_courses)) &\
                                   (ocd.OC_CoursesLinks["tgt_course_id"].isin(filter_courses)) &\
                                   ~(ocd.OC_CoursesLinks["tgt_course_id"].isin([0]))]
        tgt_courses=set(df.tgt_course_id.values) - path_courses
        #now iterate
        if (len(tgt_courses)>0):
            linked_courses_found = True
            courses_layers.append(tgt_courses)
            path_courses=path_courses | tgt_courses 
    # end while 
     
        
    if connex_paths:
        #recompute dfc
        dfc=dfc[dfc["course_id"].isin(path_courses)]
        filter_courses=path_courses
        
        
    dfcc=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(filter_courses)) & \
                             (ocd.OC_CoursesLinks["tgt_course_id"].isin(filter_courses))].drop_duplicates(subset=["src_course_id","tgt_course_id","relation"])
    
#     # if path is not selected, we show all links
#     if (path_id==0):
#         all_courses = filter_courses
#         dfcc=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(all_courses)) & \
#                              (ocd.OC_CoursesLinks["tgt_course_id"].isin(all_courses))].drop_duplicates(subset=["src_course_id","tgt_course_id","relation"])
#     else: # but if path is selected, we show all links "necessary for the path", hence hiding links not related to the path
#         all_courses = path_courses 
#         dfc=dfc[dfc["course_id"].isin(all_courses)]
#         dfcc=ocd.OC_CoursesLinks[(ocd.OC_CoursesLinks["src_course_id"].isin(all_courses)) & \
#                              (ocd.OC_CoursesLinks["tgt_course_id"].isin(all_courses))].drop_duplicates(subset=["src_course_id","tgt_course_id","relation"])

        
    if len(dfc) == 0:
        return empty_graph(height, width, bgcolor, font_color, directed,notebook,layout)
# #     # weird : len(dfc) is not equal to len(courses)
# #     # something todo later : resolve broken links due to archived courses, redirections to new courses ...
# #     full_courses = set(dfc.course_id.values)
# #     diff_courses = courses - full_courses
# #     print("there are ",len(diff_courses)," courses in the full transitive closure that were not found in the courses dataset :")
# #     display(diff_courses)
    
    # ------------------ OK NOW BUILD A GRAPH WITH dfpa, dfpr, dfpc and dfc nodes
    
    # pick what we need 
    #paths
    
    dfpa=dfpa[["topic_id","topic_color","path_id","path_title","path_language","path_level","path_duration_months","path_illustration","path_url"]].copy()
    dfmp=ocd.OC_MyProgressProjects.path_id.unique()
    dfpa["status"]=dfpa.agg(lambda x:   "in_progress" if x["path_id"] in dfmp else "none", axis=1)
    #projects
    dfpr=dfpr.merge(ocd.OC_MyProgressProjects,on=["path_id","project_number"],how="left")
    dfpr=dfpr.fillna(value={"status":"none"})
    dfpr=dfpr[["path_id","topic_id","topic_color","project_number","project_title",\
               "project_description","project_duration_hours","status"]].sort_values(by="project_number").copy()
    #projects-courses edges
    dfpc=dfpc.merge(ocd.OC_Courses, on='course_id', how='left')
    dfpc=dfpc.merge(ocd.OC_Topics[["topic_id","topic_color"]],on="topic_id",how="left")
    dfpc=dfpc[['path_id','topic_id','topic_color','project_number','course_id','course_title',\
               'course_difficulty','course_duration_hours','course_url']].copy()

    
    #courses
    dfc=dfc[['topic_id',"topic_color",'course_id','course_title','course_difficulty','course_duration_hours','course_url',"status"]].copy()
    #courses-courses edges
    #display(dfcc[dfcc.duplicated(subset=["src_course_id","tgt_course_id","relation"],keep=False)])
    dfcc=dfcc.merge(ocd.OC_Courses, left_on='src_course_id', right_on='course_id', how='left')
    dfcc=dfcc.merge(ocd.OC_Topics[["topic_id","topic_color"]],on="topic_id",how="left")
    dfcc=dfcc[['src_course_id','relation', 'tgt_course_id','course_title','course_difficulty','course_duration_hours',"topic_id","topic_color"]].copy ()
    dfcc.columns=['src_course_id','relation', 'tgt_course_id', \
                  'src_course_title','src_course_difficulty','src_course_duration_hours',"src_topic_id","src_topic_color"]
    dfcc=dfcc.merge(ocd.OC_Courses, left_on='tgt_course_id', right_on='course_id', how='left')
    dfcc=dfcc.merge(ocd.OC_Topics[["topic_id","topic_color"]],on="topic_id",how="left")
    dfcc=dfcc[['src_course_id','relation', 'tgt_course_id', \
               'src_course_title','src_course_difficulty','src_course_duration_hours',"src_topic_id","src_topic_color",\
               'course_title','course_difficulty','course_duration_hours',"topic_id","topic_color"]].copy ()
    dfcc.columns=['src_course_id','relation', 'tgt_course_id', \
                  'src_course_title','src_course_difficulty','src_course_duration_hours',"src_topic_id","src_topic_color",\
                  'tgt_course_title','tgt_course_difficulty','tgt_course_duration_hours',"tgt_topic_id","tgt_topic_color"]
    
    # add unique ids and other columns for the graph    
    # convert textual uids into a global numeric unique ids because PyVis doesn't like string ids 
    aia= AssociativeIdentifierArray()
    #note that dfpa can be empty when we explore a topic having no path
    if len(dfpa)>0:
        dfpa["uid"]=dfpa.agg(lambda x: f"p_{x['path_id']}", axis=1)
        aia.record_object_id_array(dfpa.uid.values)
        dfpa["nid"]=dfpa["uid"].apply(aia.get_numeric_id_for_object_id)
    else :
        dfpa.assign(colname="uid")        
        dfpa.assign(colname="nid")
    
    if len(dfpr)>0:
        dfpr["path_uid"]=dfpr.agg(lambda x: f"p_{x['path_id']}", axis=1)
        dfpr["uid"]=dfpr.agg(lambda x: f"p_{x['path_id']}-pn_{x['project_number']}", axis=1)
        aia.record_object_id_array(dfpr.uid.values) 
        aia.record_object_id_array(dfpr.path_uid.values)
        dfpr["nid"]=dfpr["uid"].apply(aia.get_numeric_id_for_object_id)
        dfpr["path_nid"]=dfpr["path_uid"].apply(aia.get_numeric_id_for_object_id)
    else : 
        dfpr.assign(colname="path_uid")
        dfpr.assign(colname="uid")
        dfpr.assign(colname="path_nid")
        dfpr.assign(colname="nid")
    
    if len(dfpc)>0:
        dfpc["path_uid"]=dfpc.agg(lambda x: f"p_{x['path_id']}", axis=1)
        dfpc["src_uid"]=dfpc.agg(lambda x: f"p_{x['path_id']}-pn_{x['project_number']}", axis=1)
        dfpc["tgt_uid"]=dfpc.agg(lambda x: f"c_{x['course_id']}", axis=1)
        dfpc["course_difficulty_grade"]=dfpc['course_difficulty'].map(ocd.course_grades)        
        aia.record_object_id_array(dfpc.path_uid.values)
        aia.record_object_id_array(dfpc.src_uid.values)
        aia.record_object_id_array(dfpc.tgt_uid.values) 
        dfpc["path_nid"]=dfpc["path_uid"].apply(aia.get_numeric_id_for_object_id)
        dfpc["src_nid"]=dfpc["src_uid"].apply(aia.get_numeric_id_for_object_id)
        dfpc["tgt_nid"]=dfpc["tgt_uid"].apply(aia.get_numeric_id_for_object_id)
    else :
        dfpc.assign(colname="path_uid")
        dfpc.assign(colname="src_uid")
        dfpc.assign(colname="tgt_uid")
        dfpc.assign(colname="course_difficulty_grade")
        dfpc.assign(colname="path_nid")
        dfpc.assign(colname="src_nid")
        dfpc.assign(colname="tgt_nid") 
    
    
    dfc["uid"]=dfc.agg(lambda x: f"c_{x['course_id']}", axis=1)
    dfc["course_difficulty_grade"]=dfc['course_difficulty'].map(ocd.course_grades)
    aia.record_object_id_array(dfc.uid.values)
    dfc["nid"]=dfc["uid"].apply(aia.get_numeric_id_for_object_id)
    
    if len(dfcc)>0:
        dfcc["src_uid"]=dfcc.agg(lambda x: f"c_{x['src_course_id']}", axis=1)
        dfcc["tgt_uid"]=dfcc.agg(lambda x: f"c_{x['tgt_course_id']}", axis=1)
        dfcc["src_course_difficulty_grade"]=dfcc['src_course_difficulty'].map(ocd.course_grades)
        dfcc["tgt_course_difficulty_grade"]=dfcc['tgt_course_difficulty'].map(ocd.course_grades)
        aia.record_object_id_array(dfcc.src_uid.values)
        aia.record_object_id_array(dfcc.tgt_uid.values)    
        dfcc["src_nid"]=dfcc["src_uid"].apply(aia.get_numeric_id_for_object_id)
        dfcc["tgt_nid"]=dfcc["tgt_uid"].apply(aia.get_numeric_id_for_object_id)
    else :
        dfcc.assign(colname="src_uid")
        dfcc.assign(colname="tgt_uid")
        dfcc.assign(colname="src_course_difficulty_grade")
        dfcc.assign(colname="tgt_course_difficulty_grade") 
        dfcc.assign(colname="src_nid")
        dfcc.assign(colname="tgt_nid")  
  
    
    # build the graph nodes
    if type(heading) == type(None) :
        g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout)
    else : 
        g = Network(height = height, width=width, bgcolor=bgcolor, font_color=font_color, directed=directed,notebook=notebook,layout=layout,heading=heading)
    g.toggle_physics(True) 
    
    grav=-8000
    if (len(dfc)>500 or (len(dfcc)+len(dfpc)>500)):
        grav=-40000
    elif (len(dfc)>100 or (len(dfcc)+len(dfpc)>100)):
        grav=-20000
    elif (len(dfc)>30 or (len(dfcc)+len(dfpc)>30)):
        grav=-15000
        
    physics_model="barneshut"  
    if atlas_layout:
        physics_model="forceatlas" #="barneshut"
    if physics_model=="barneshut":
        g.barnes_hut(gravity=grav,
            central_gravity=0.01,
            spring_length=180,
            spring_strength=0.001,
            damping=0.03,
            overlap=0.1)   
    elif physics_model=="forceatlas":
        g.force_atlas_2based(gravity=-400, 
                             central_gravity=0.02, 
                             spring_length=150, 
                             spring_strength=0.08, 
                             damping=0.4, 
                             overlap=0.2) 

#     Node shape : The shape defines what the node looks like. There are two types of nodes. 
#     One type has the label inside of it and the other type has the label underneath it. 
#     The types with the label inside of it are: ellipse, circle, database, box, text. 
#     The ones with the label outside of it are: image, circularImage, diamond, dot, star, triangle, triangleDown, square and icon.
    link_colors={
        "primary_requires"    : "#2D2", # the requirement links between a project and courses
        "primary_references"  : "#22D", # the "other" links between a project and courses (the list is empty but we have a color for that :) )
        "secundary_requires"  : "#8C2", # the requirement links between courses of depth D to depth D+1
        "secundary_references": "#82C", # the other links between courses of depth D to depth D+1
        "tertiary_requires"   : "#DB2", #the requirement links between courses of depth D to any depth other than D+1
        "tertiary_references" : "#D2B", # the other links between courses of depth D to any depth other than D+1
        "long_link"           : "#BB8", # the other long distance links
    }
    
    #"my way" colors
    status_colors={
        "none"                : "#CCC", # use topic color instead 
        "todo_course"         : "#92f2ff",
        "todo"                : "#1ae4ff", 
        "in_progress_course"  : "#FFF222", 
        "in_progress"         : "#f9f900", 
        "done_course"         : "#95ff00",
        "done"                : "#80DD00" 
    }
    oc_colors=["#7451eb","#9471fb","#B491FE"]

    path_shape="star"
    path_size="80"
    path_color="#7451eb"
    
    project_shape="square"
    project_size="40"
    project_color="#5451db"
    
    course_shape="triangle"
    course_color="#B491FE"
    course_size="10"
    path_course_size="30"
    
    part_shape="triangleDown"
    part_size="8"
    
    chapter_shape="dot"
    chapter_size="8"
    
    
    marker_color="#cc00ff"
    marker_shape="diamond"
    
    # to avoid multiple display of the same elements
    added_nodes=set() 
    added_edges=set()
    
    # --------- PATHs (if shown)
    for i,n in dfpa.iterrows():
        if n["nid"] in added_nodes: 
            continue
        added_nodes.add(n["nid"])
        color=path_color #dependency palette
        if (palette=="Topic" or palette=="Hybrid"): #topic palette
            color=n["topic_color"]
        if (show_my_way and n["status"]!="none"):
            color=status_colors[n["status"]] 
        if (show_titles):
            g.add_node(n["nid"], n["path_title"],color=color,shape=path_shape,size=path_size,\
                       physics=True,title="<a href=\""+n["path_url"]+"\" target=\"_blank\">"+n["path_title"]+"</a>")
        else:
            g.add_node(n["nid"], n["path_title"],color=color ,shape=path_shape,size=path_size,physics=True) 
        
        # if no path is selected and no path topic is selected, we show all paths but we don't show their inner projects
        # otherwise we show the projects of the selected path or topic paths
        if path_id!=0 or path_topic_id!=0:
            # ---------- PROJECTS 
            previous_uid=n["uid"]
            previous_nid=n["nid"]
            for ii,nn in dfpr[dfpr["path_id"].isin([n["path_id"]])].iterrows():
                if nn["nid"] not in added_nodes: 
                    added_nodes.add(nn["nid"])
            #             length = plength+ nn["project_duration_hours"] 
                    color=project_color
                    if (palette=="Topic"):
                        color=n["topic_color"]
                    if (show_my_way == True) and (nn["status"]!="none"):
                        color=status_colors[nn["status"]] 
                    color=get_darker_color(color,30)
                    if (show_titles):
                        g.add_node(int(nn["nid"]), str(nn["project_number"])+"-"+nn["project_title"], color=color,\
                                   shape=project_shape,size=project_size, physics=True,title=nn["project_title"])
                    else:
                        g.add_node(int(nn["nid"]), str(nn["project_number"])+"-"+nn["project_title"], color=color,\
                                   shape=project_shape,size=project_size, physics=True) 
                fs=frozenset([previous_nid,nn["nid"]])
                if fs not in added_edges: 
                    added_edges.add(fs)
                    color=project_color
                    if (palette=="Topic"):
                        color=nn["topic_color"]
                    if (show_my_way == True) and (nn["status"]!="none"):
                        color=status_colors[nn["status"]]
                    color=get_darker_color(color,30)
                    g.add_edge(previous_nid, int(nn["nid"]),label=str(int(nn["project_duration_hours"]))+"h",color={'color':color, 'inherit':'false'},value=2)
                previous_uid=nn["uid"]
                previous_nid=int(nn["nid"])
            # end loop on projects
#             fs=frozenset([previous_nid,n["nid"]]) #closing the path wheel
#             if fs not in added_edges: 
#                 added_edges.add(fs)
#                 color=project_color
#                 if (palette=="Topic"):
#                     color=n["topic_color"]
#                 if (show_my_way == True) and (nn["status"]!="none"):
#                     color=status_colors[nn["status"]]
#                 g.add_edge(previous_nid, int(n["nid"]),label="jury",color=color,value=2)
        # end if we show projects
    # end loop on paths

    # --------- COURSES
    for i,n in dfc.iterrows():
        if n["nid"] in added_nodes: 
            continue
        added_nodes.add(n["nid"])
        color=course_color
        size_coeff=1
        if int(n["course_id"]) in path_courses:
            size_coeff=2
        if (palette=="Topic" or palette=="Hybrid"):
            color=n["topic_color"] 
        if (show_my_way == True) and (n["status"]!="none"):
            color=status_colors[n["status"]+"_course"]  
        if (show_titles):
            g.add_node(n["nid"], n["course_title"],color=color,size=n["course_difficulty_grade"]*10*size_coeff ,\
                       shape=course_shape,physics=True,title="<a href=\""+n["course_url"]+"\" target=\"_blank\">"+n["course_title"]+"</a>")
        else:
            g.add_node(n["nid"], n["course_title"],color=color,size=n["course_difficulty_grade"]*10*size_coeff,\
                       shape=course_shape,physics=True)
    
    
    # ---------- LINKING PROJECTS TO COURSES
    # if no path is selected and no path topic is selected, we show all paths but we don't show their inner projects
    # otherwise we show the projects of the selected paths
    if path_id!=0 or path_topic_id!=0:
        for i,e in dfpc.iterrows():  
#             if e["tgt_nid"] not in added_nodes: 
#                 added_nodes.add(e["tgt_nid"])
#                 color=course_color
#                 if (palette=="Topic" or palette=="Hybrid"):
#                     color=e["topic_color"]
#                 color=marker_color #debug 
#                 if (show_titles):
#                     g.add_node(e["tgt_nid"], e["course_title"],group="course",color=color,size=e["course_difficulty_grade"]*20 ,\
#                                shape=marker_shape,physics=True,title=str(e["tgt_uid"])+"/"+str(e["tgt_nid"])+"/"+str(e["course_difficulty_grade"]*20))
#                 else:
#                     g.add_node(e["tgt_nid"], e["course_title"],group="course",color=color,size=e["course_difficulty_grade"]*20 ,\
#                                shape=marker_shape,physics=True)
            try:
                fs=frozenset([int(e["src_nid"]),int(e["tgt_nid"])])
                if fs not in added_edges: 
                    added_edges.add(fs)
                    gns=g.get_node(e["src_nid"])
                    gnt=g.get_node(e["tgt_nid"])        
                    duration=int(e["course_duration_hours"])
                    if duration==np.nan:
                        duration=0
                    color=link_colors["primary_requires"]
                    if (palette=="Topic"):
                        color=e["topic_color"]
                    g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(duration)+"h",color={'color':color, 'inherit':'false'},value=2)    
            except:
                console_log("error accessing data for project-course link ",e)
                return
        # end loop on links           
    else: # we do not show projects when no path is selected, so link project courses to path node instead
        for i,e in dfpc.iterrows(): 
#             if e["tgt_nid"] not in added_nodes: 
#                 added_nodes.add(e["tgt_nid"])
#                 color=course_color
#                 if (palette=="Topic" or palette=="Hybrid"):
#                     color=e["topic_color"]
#                 color=marker_color #debug
#                 if (show_titles):
#                     g.add_node(e["tgt_nid"], e["course_title"],group="course",color=color,size=e["course_difficulty_grade"]*10 ,\
#                                shape=marker_shape,physics=True,title=str(e["tgt_uid"])+"/"+str(e["tgt_nid"])+"/"+str(e["course_difficulty_grade"]*10))
#                 else:
#                     g.add_node(e["tgt_nid"], e["course_title"],group="course",color=color,size=e["course_difficulty_grade"]*10 ,\
#                                shape=marker_shape,physics=True)
            try:
                fs=frozenset([int(e["path_nid"]),int(e["tgt_nid"])])
                if fs not in added_edges: 
                    added_edges.add(fs)
                    gns=g.get_node(e["path_nid"])
                    gnt=g.get_node(e["tgt_nid"])        
                    duration=int(e["course_duration_hours"])
                    if duration==np.nan:
                        duration=0
                    color=link_colors["primary_requires"]
                    if (palette=="Topic"):
                        color=e["topic_color"]
                    g.add_edge(int(e["path_nid"]), int(e["tgt_nid"]),label=str(duration)+"h",color={'color':color, 'inherit':'false'})    
            except:
                console_log("error accessing data for path-course link ",e)
                return
        # end loop on links           
    # attention, il y a des liens cassés car des cours connus par leur lien sont introuvables dans la liste des cours

    # ------------ LINKING COURSES TO COURSES 
    # we use the set path_courses built with all courses belonging to the paths/projects requirement network under a given max-depth depth.
    # (ie for links belonging to projects requirement structure)
    for i,e in dfcc.iterrows():
        if (e["src_nid"]==e["tgt_nid"]): #avoid auto linking
            continue
        fs=frozenset([int(e["src_nid"]),int(e["tgt_nid"])])
        if fs not in added_edges: 
            color="#ccc"
            title="unknown link"
            edge_value=0
            if (e["relation"]=="requires"):
                color=link_colors["secundary_requires"]
                if path_id!=0 or path_topic_id!=0:
                    edge_value=2
                if (int(e["src_course_id"]) not in path_courses) or (int(e["tgt_course_id"]) not in path_courses):
                    edge_value=0
                    if (palette=="Hybrid"):
                        color=get_lighter_color(e["tgt_topic_color"],20)
                if (palette=="Topic"):
                    color=get_lighter_color(e["tgt_topic_color"],20)
            else:
                if (show_only_requirement_relations==True):  
                    continue
                color=link_colors["secundary_references"]
                title="references 2"
                if path_id!=0 or path_topic_id!=0:
                    edge_value=2
                if (int(e["src_course_id"]) not in path_courses) or (int(e["tgt_course_id"]) not in path_courses):
                    edge_value=0
                    if (palette=="Hybrid"):
                        color=get_lighter_color(e["tgt_topic_color"],20)
                if (palette=="Topic"):
                    color=get_lighter_color(e["tgt_topic_color"],50) 
            duration=int(e["tgt_course_duration_hours"])
            if duration==np.nan:
                duration=0
            added_edges.add(fs)
            if (edge_value==0):
                g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(duration)+"h",color={'color':color, 'inherit':'false'})
            else:
                g.add_edge(int(e["src_nid"]), int(e["tgt_nid"]),label=str(duration)+"h",color={'color':color, 'inherit':'false'},value=edge_value)    
            
    # end loop on links
    
    # finally animate and export the graph
        
    if (show_buttons):
        g.show_buttons(filter_="physics") 
    if (notebook==True):
        g.prep_notebook(custom_template=True, custom_template_path=VizTemplate)
    else: 
        g.set_template(VizTemplate)
    return g
#end function
